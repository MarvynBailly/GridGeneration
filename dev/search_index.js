var documenterSearchIndex = {"docs":
[{"location":"pages/2Dto1D/MetricReformulation/#Metric-Reformulation","page":"Metric Reformulation","title":"Metric Reformulation","text":"","category":"section"},{"location":"pages/2Dto1D/MetricReformulation/#2D-to-1D-Mapping","page":"Metric Reformulation","title":"2D to 1D Mapping","text":"","category":"section"},{"location":"pages/2Dto1D/MetricReformulation/#Local-Mapping","page":"Metric Reformulation","title":"Local Mapping","text":"","category":"section"},{"location":"pages/2Dto1D/MetricReformulation/","page":"Metric Reformulation","title":"Metric Reformulation","text":"Suppose we wish to solve the grid spacing along a discrete boundary Gamma given by the points gamma_i in R^2 for i=12dots n where n is the total number of points along the boundary. In-between each point is a linear interpolation Gamma_i for i=12dotsn-1 which defines the piecewise-continuous boundary. ","category":"page"},{"location":"pages/2Dto1D/MetricReformulation/","page":"Metric Reformulation","title":"Metric Reformulation","text":"To find the grid spacing according to the 2D metric tensor M, let's compute a new m value to represent the desired metric stretching in R rather than R^2. Let's define m_i as","category":"page"},{"location":"pages/2Dto1D/MetricReformulation/","page":"Metric Reformulation","title":"Metric Reformulation","text":"m_i = frac1gamma_i+1 - gamma_i-1^2(gamma_i+1 - gamma_i-1)^top cdot  beginpmatrix M_11  M_12  M_21  M_22 endpmatrix_i cdot (gamma_i+1 - gamma_i-1) quad i=2cdots n - 1","category":"page"},{"location":"pages/2Dto1D/MetricReformulation/","page":"Metric Reformulation","title":"Metric Reformulation","text":"and one sided differences for the edges","category":"page"},{"location":"pages/2Dto1D/MetricReformulation/","page":"Metric Reformulation","title":"Metric Reformulation","text":"m_1 = frac1gamma_2 - gamma_1^2(gamma_2 - gamma_1)^top  cdot beginpmatrix M_11  M_12  M_21  M_22 endpmatrix_1 cdot (gamma_2 - gamma_1)","category":"page"},{"location":"pages/2Dto1D/MetricReformulation/","page":"Metric Reformulation","title":"Metric Reformulation","text":"m_n = frac1gamma_n - gamma_n-1^2(gamma_n - gamma_n-1)^top cdot beginpmatrix M_11  M_12  M_21  M_22 endpmatrix_n cdot (gamma_n - gamma_n-1)","category":"page"},{"location":"pages/2Dto1D/MetricReformulation/","page":"Metric Reformulation","title":"Metric Reformulation","text":"This is basically a local normalized product between a central difference on x_i and the local M_i tensor. Let's call this method \"local.\"","category":"page"},{"location":"pages/2Dto1D/MetricReformulation/#Note","page":"Metric Reformulation","title":"Note","text":"","category":"section"},{"location":"pages/2Dto1D/MetricReformulation/","page":"Metric Reformulation","title":"Metric Reformulation","text":"Using the nuclear norm might by bad because it would change the metric value.","category":"page"},{"location":"pages/2Dto1D/MetricReformulation/#Algorithm","page":"Metric Reformulation","title":"Algorithm","text":"","category":"section"},{"location":"pages/2Dto1D/MetricReformulation/","page":"Metric Reformulation","title":"Metric Reformulation","text":"We can compute the metric value m_i using the following ","category":"page"},{"location":"pages/2Dto1D/MetricReformulation/","page":"Metric Reformulation","title":"Metric Reformulation","text":"function Get1DMetric(points, getMetric; method = \"local\")\n    function norm(v)\n        return sqrt(v[1]^2 + v[2]^2)\n    end\n\n    n = size(points, 2)\n    m = zeros(Float64, n)\n    diff = zeros(Float64, 2, n)\n\n    diff[:, 2:n-1] = (points[:, 3:n] - points[:, 1:n-2])     \n    diff[:, n] = (points[:, n] - points[:, n-1]) \n    diff[:,1] = points[:, 2] - points[:, 1] \n    \n    for i in 1:n\n        # get metric value for the points M\n        M = getMetric(points[1, i], points[2, i])\n\n        localDiff = diff[:, i]\n        normLocalDiff = norm(localDiff)\n        m[i] = localDiff' * M * localDiff / normLocalDiff^2\n        end\n    end\n\n    return m\nend","category":"page"},{"location":"pages/2Dto1D/MetricReformulation/#Results","page":"Metric Reformulation","title":"Results","text":"","category":"section"},{"location":"pages/2Dto1D/MetricReformulation/","page":"Metric Reformulation","title":"Metric Reformulation","text":"We look at three metric cases:","category":"page"},{"location":"pages/2Dto1D/MetricReformulation/","page":"Metric Reformulation","title":"Metric Reformulation","text":"Uniform.\nClustering at x=00\nClustering at x=1","category":"page"},{"location":"pages/2Dto1D/MetricReformulation/","page":"Metric Reformulation","title":"Metric Reformulation","text":"Let's refer to the real metric tensor as M(x(s)) and the computed 1D metric tensor as m(x(s)).","category":"page"},{"location":"pages/2Dto1D/MetricReformulation/","page":"Metric Reformulation","title":"Metric Reformulation","text":"Extracted Boundary Gamma with discrete boundary points gamma_i, linear interpolates Gamma_i, and computed 1D metric values along it are shown in the following plot. Note that the direction of parametrization s is shown by the red arrow.","category":"page"},{"location":"pages/2Dto1D/MetricReformulation/","page":"Metric Reformulation","title":"Metric Reformulation","text":"(Image: uniform-metricboundary) (Image: x=0-metricboundary) (Image: x=1-metricboundary)","category":"page"},{"location":"pages/MultiBlock/multiblock/#Multi-Block-with-Splitting","page":"Multi-Block Input","title":"Multi-Block with Splitting","text":"","category":"section"},{"location":"pages/MultiBlock/multiblock/","page":"Multi-Block Input","title":"Multi-Block Input","text":"To allow the user to input a multi-block Tortuga grid, all that we have to do is add compatibility to the GridGeneration.SplitBlock(block, splitLocations, bndInfo, interInfo) to allow for multiple blocks rather than the single block. Let's call this function GridGeneration.SplitBlocks(blocks, splitLocations, bndInfo, interInfo).","category":"page"},{"location":"pages/MultiBlock/multiblock/#Split-Blocks-Algorithm","page":"Multi-Block Input","title":"Split Blocks Algorithm","text":"","category":"section"},{"location":"pages/ODE/ODEFormulation/#Ordinary-Differential-Equation-for-Metric-Conforming-Structured-Grid-Generator","page":"ODE Formulation","title":"Ordinary Differential Equation for Metric-Conforming Structured Grid Generator","text":"","category":"section"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"The aim is to create a simple metric-conforming structured grid generator by dividing the entire domain Omega into sub-domains hatOmega_i known as blocks. Along the sides of the blocks, we solve a 1D grid-spacing problem through the calculus of variation whose solution gives a coordinate mapping for the distribution of points according to the metric tensor. An algebraic method known as Transfinite Interpolation is used to fill in each block by interpolating the distribution of points along the edges into 2D. Supporting mathematical steps are shown in the Appendix.","category":"page"},{"location":"pages/ODE/ODEFormulation/#General-Grid-Spacing-Problem","page":"ODE Formulation","title":"General Grid-Spacing Problem","text":"","category":"section"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"We define the metric","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"m_alpha(x_s x s) = sigma_alpha^2  M x_s^2 - 1","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"where M(x(s)) is the metric tensor field designed from the residual posterior estimate, x is the physical domain and s is the computational domain. We will use variable subscripts to notation derivatives left( x_s = fracdxds right). Next, we define our loss as ","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"L_textmisfit(x_s x s) = m_alpha^2","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"which we use to define the functional  ","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"mathcalLx(s) = int_Omega L(x(s) x_s(s) s) d s","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"From variations we know the general solution is the Euler-Lagrange equation","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"fracpartial Lpartial x- fracdd s fracpartial Lpartial x_s = 0","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"For this choice of kernel L_textmisfit, the solution in R^n is a second-order nonlinear PDE of the form","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"-sum_alpha=1^n 8 sigma_alpha^4 M_klfracpartial x_lpartial s_alpha M_ij fracpartial x_ipartial s_alpha fracpartial^2 x_jpartial s_alpha^2 - sum_alpha = 1^n 4 sigma_alpha^4 M_kl fracpartial x_lpartial s_alphafracpartial M_ijpartial x_p fracpartial x_ppartial s_alpha fracpartial x_ipartial s_alpha fracpartial x_jpartial s_alpha - sum_alpha=1^n m_alpha sigma_alpha^2left( 4 M_kj fracpartial^2 x_jpartial s_alpha^2 + 4 fracpartial M_kjpartial x_pfracpartial x_ppartial x_s fracpartial x_jpartial s_alpha  - 2 fracpartial M_ijpartial x_kfracpartial x_ipartial s_alpha  fracpartial x_jpartial s_alpha right) = 0 k in 1 2 dots n","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"where Einstein Notation is used for non-Greek subscripts. ","category":"page"},{"location":"pages/ODE/ODEFormulation/#1D-Grid-Spacing","page":"ODE Formulation","title":"1D Grid-Spacing","text":"","category":"section"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"In R, the above PDE turns into a friendly nonlinear ODE.","category":"page"},{"location":"pages/ODE/ODEFormulation/#Second-Order-ODE","page":"ODE Formulation","title":"Second Order ODE","text":"","category":"section"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"Simplifying the above equation with n=1 yields a second-order nonlinear ODE of the form ","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"boxed 8 sigma^4  M^2 x_s^2 x_ss  + 4 sigma^4  M M_x x_s^4 + 4sigma^2 m M x_ss + 2 sigma^2 m M_x x_s^2  = 0 ","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"with dirichlet boundary conditions","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"x(0) = x_0 quad x(1) = x_1","category":"page"},{"location":"pages/ODE/ODEFormulation/#First-Order-System-of-ODEs","page":"ODE Formulation","title":"First Order System of ODEs","text":"","category":"section"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"We can rewrite the second order ODE as a system of first order ODEs by letting u_1 = x and u_2 = x_s to find","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"begincases \nu_1 = u_2 = x\nu_2 = x = - frac12 fracM_xMx_s^2\nendcases","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"with dirichlet boundary conditions:","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"u_1(1) = x_1 u_1(0) = x_0 u_2(0) = u_2(1) = 0","category":"page"},{"location":"pages/ODE/ODEFormulation/#Optimal-Grid-Spacing","page":"ODE Formulation","title":"Optimal Grid Spacing","text":"","category":"section"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"We also require that ","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"fracpartial Lpartial sigma = 0","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"which gives us the condition","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"boxedsigma = left( fracint_hatOmega M x^2 dsint_hatOmega (M x^2)^2 ds right)^12","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"where sigma = frac1n_textopt. ","category":"page"},{"location":"pages/ODE/ODEFormulation/","page":"ODE Formulation","title":"ODE Formulation","text":"We aim to solve the boxed equation numerically to find the distribution of points along the boundary of the blocks.","category":"page"},{"location":"pages/SingleBlock/nosplitting/#Single-Block-with-No-Splitting","page":"Single Block with No Splitting","title":"Single Block with No Splitting","text":"","category":"section"},{"location":"pages/SingleBlock/nosplitting/#2D-Single-Block","page":"Single Block with No Splitting","title":"2D Single Block","text":"","category":"section"},{"location":"pages/SingleBlock/nosplitting/","page":"Single Block with No Splitting","title":"Single Block with No Splitting","text":"Let's start by allowing the user to input a single Tortuga block in the code. Thus the input will be the initial grid and the boundary information. The code will take in a 2D grid and solve the ODE along each edge of the domain. As the optimal number of points need not be the same for boundary edges across from each other, the code will proceed to resolve the edge that does not have the maximum number of points. Finally, the code will solve for the interior points using Transfinite Interpolation and update the boundary information with the new dimensions of the block. ","category":"page"},{"location":"pages/SingleBlock/nosplitting/#Algorithm","page":"Single Block with No Splitting","title":"Algorithm","text":"","category":"section"},{"location":"pages/SingleBlock/nosplitting/","page":"Single Block with No Splitting","title":"Single Block with No Splitting","text":"To solve a single block, we can pair up the left and top edges with the right and bottom edges respectively. For each pair, we do the following:","category":"page"},{"location":"pages/SingleBlock/nosplitting/","page":"Single Block with No Splitting","title":"Single Block with No Splitting","text":"for each pair:\nfor each edge in pair\nCompute the 1D metric along the edge using GridGeneration.Get1DMetric(pnts, metricFunction)\nProject the edge to 1D using GridGeneration.ProjectBoundary2Dto1D(edge)\nSolve the ODE problem using the 1D metric and 1D points using GridGeneration.SolveODE(m,m,N,xs)\nCompute the optimal number of points using GridGeneration.ComputeOptimalNumberofPoints(xs, m, sol)\nset optimal number of points for pair to the max of the edge optimal numbers\nfor each edge\nSolve the ODE problem using the pair optimal number of points using GridGeneration.ComputeOptimalNumberofPoints(xs, m, sol)\nSave edge distribution\nRun TFI on edge distributions to get final grid using GridGeneration.TFI_2D(boundary)","category":"page"},{"location":"pages/SingleBlock/nosplitting/","page":"Single Block with No Splitting","title":"Single Block with No Splitting","text":"Writing this in Julia:","category":"page"},{"location":"pages/SingleBlock/nosplitting/","page":"Single Block with No Splitting","title":"Single Block with No Splitting","text":"function ProcessEdgePair(edgeA, edgeB, metricFunc, solver)\n    metricA = GridGeneration.Get1DMetric(edgeA, metricFunc)\n    metricB = GridGeneration.Get1DMetric(edgeB, metricFunc)\n\n    xsA = GridGeneration.ProjectBoundary2Dto1D(edgeA)\n    xsB = GridGeneration.ProjectBoundary2Dto1D(edgeB)\n\n    solA = GridGeneration.SolveODE(metricA, metricA, length(xsA), xsA; method=solver)\n    solB = GridGeneration.SolveODE(metricB, metricB, length(xsB), xsB; method=solver)\n\n    optNA = GridGeneration.ComputeOptimalNumberofPoints(xsA, metricA, solA[1, :])\n    optNB = GridGeneration.ComputeOptimalNumberofPoints(xsB, metricB, solB[1, :])\n\n    optN = max(optNA, optNB)\n    @info \"Optimal number of points: $optN\"\n\n    solOptA = GridGeneration.SolveODE(metricA, metricA, optN, xsA; method=solver)\n    solOptB = GridGeneration.SolveODE(metricB, metricB, optN, xsB; method=solver)\n\n    projectedA = GridGeneration.ProjectBoundary1Dto2D(edgeA, solOptA[1, :], xsA)\n    projectedB = GridGeneration.ProjectBoundary1Dto2D(edgeB, solOptB[1, :], xsB)\n\n    return projectedA, projectedB\nend\n\nfunction SolveBlock(block, bndInfo, interInfo, metricFunc; solver=\"analytic\")\n    left   = block[:, 1, :]\n    right  = block[:, end, :]\n    projectedLeft, projectedRight = ProcessEdgePair(left, right, metricFunc, solver)\n\n    bottom = block[:, :, 1]\n    top    = block[:, :, end]\n    projectedBottom, projectedTop = ProcessEdgePair(bottom, top, metricFunc, solver)\n\n    computedBlock = GridGeneration.TFI_2D([projectedTop', projectedRight', projectedBottom', projectedLeft'])\n\n    bndInfo = GridGeneration.UpdateBndInfo!(bndInfo, computedBlock)\n\n    return computedBlock, bndInfo, interInfo\nend","category":"page"},{"location":"pages/SingleBlock/nosplitting/#Custom-Metric","page":"Single Block with No Splitting","title":"Custom Metric","text":"","category":"section"},{"location":"pages/SingleBlock/nosplitting/","page":"Single Block with No Splitting","title":"Single Block with No Splitting","text":"Let's also create a tool to output a custom metric field. I make this function by computing the distance from the airfoil to the point with the following w_rational(d, A, ℓ, p) = A / (1 + (d/ℓ)^p) where d is the distance, A controls the amplitude, and l and p are used to control the fall off. This gives the space around the airfoil a higher metric value which decreases as you move away from the boundary. Let's also add a \"hotspot\" to control where the function places more points. We can achieve this by using the same function from above but rather than using the distance from the airfoil, we pass in the distance to the (texthotspot_x texthotspot_y). Finally we can add these two functions togethers.","category":"page"},{"location":"pages/SingleBlock/nosplitting/#Examples","page":"Single Block with No Splitting","title":"Examples","text":"","category":"section"},{"location":"pages/SingleBlock/nosplitting/","page":"Single Block with No Splitting","title":"Single Block with No Splitting","text":"Let's use a small grid around an airfoil as an example. Looping over hotspots along the airfoil domain we can make some fun gifs as shown below. We see that the basic TFI method struggles to preserve orthogonality in the interior points but I'm not worried about this. We can use higher order TFI methods or elliptic smoothing to remedy this.","category":"page"},{"location":"pages/SingleBlock/nosplitting/#Example-1","page":"Single Block with No Splitting","title":"Example 1","text":"","category":"section"},{"location":"pages/SingleBlock/nosplitting/","page":"Single Block with No Splitting","title":"Single Block with No Splitting","text":"(Image: test)","category":"page"},{"location":"pages/SingleBlock/nosplitting/#Example-2","page":"Single Block with No Splitting","title":"Example 2","text":"","category":"section"},{"location":"pages/SingleBlock/nosplitting/","page":"Single Block with No Splitting","title":"Single Block with No Splitting","text":"(Image: test)","category":"page"},{"location":"pages/SingleBlock/nosplitting/#Example-3","page":"Single Block with No Splitting","title":"Example 3","text":"","category":"section"},{"location":"pages/SingleBlock/nosplitting/","page":"Single Block with No Splitting","title":"Single Block with No Splitting","text":"(Image: test)","category":"page"},{"location":"pages/GridFormat/#Grid-Format","page":"Grid Format","title":"Grid Format","text":"","category":"section"},{"location":"pages/GridFormat/","page":"Grid Format","title":"Grid Format","text":"To save multi-block grids, we will use \"Tortuga Format\" used by Dr. Larsson's Computational Turbulence Laboratory. ","category":"page"},{"location":"pages/GridFormat/","page":"Grid Format","title":"Grid Format","text":"The format saves three pieces of information which can easily be dumped to binary and loaded into his in-house solver. All grids inputted into GridGeneration.jl are expected to be in this format.","category":"page"},{"location":"pages/GridFormat/#Boundary-Information","page":"Grid Format","title":"Boundary Information","text":"","category":"section"},{"location":"pages/GridFormat/","page":"Grid Format","title":"Grid Format","text":"An array of dicts of the form","category":"page"},{"location":"pages/GridFormat/","page":"Grid Format","title":"Grid Format","text":"Dict(\"faces\" => faces, \"name\" => name)","category":"page"},{"location":"pages/GridFormat/","page":"Grid Format","title":"Grid Format","text":"where faces is an array of dicts","category":"page"},{"location":"pages/GridFormat/","page":"Grid Format","title":"Grid Format","text":"faces = Any[ \n    Dict(\"start\" => [startni, startnj, startnk], \"end\" => [endni, endnj, endnk], \"blockId\" = blockId),\n    Dict(\"start\" => [startni, startnj, startnk], \"end\" => [endni, endnj, endnk], \"blockId\" = blockId),\n]","category":"page"},{"location":"pages/GridFormat/#Interface-Information","page":"Grid Format","title":"Interface Information","text":"","category":"section"},{"location":"pages/GridFormat/","page":"Grid Format","title":"Grid Format","text":"An array of dicts of the forms","category":"page"},{"location":"pages/GridFormat/","page":"Grid Format","title":"Grid Format","text":"Dict(\n    \"blockA\" => blockAId, \"start_blkA\" => [niStartA,njStartA,nkStartA], \"end_blkA\" => [niEndA,njEndA,nkEndA],\n    \"blockB\" => blockBId, \"start_blkB\" => [niStartB,njStartB,nkStartB], \"end_blkB\" => [niEndB,njEndB,nkEndB],\n    \"offset\" => [0.0, 0.0, 0.0], \"angle\" => 0.0\n)","category":"page"},{"location":"pages/GridFormat/#Block-Information","page":"Grid Format","title":"Block Information","text":"","category":"section"},{"location":"pages/GridFormat/","page":"Grid Format","title":"Grid Format","text":"An array of arrays ","category":"page"},{"location":"pages/GridFormat/","page":"Grid Format","title":"Grid Format","text":"blocks = [block1, block2, ...]","category":"page"},{"location":"pages/GridFormat/","page":"Grid Format","title":"Grid Format","text":"where each block is of size (3, ni, nj, nk) containing the (ijk) coordinates for each grid point within this block.","category":"page"},{"location":"pages/Examples/airfoil/#Airfoil-Examples","page":"Airfoil","title":"Airfoil Examples","text":"","category":"section"},{"location":"pages/Examples/airfoil/#Uniform","page":"Airfoil","title":"Uniform","text":"","category":"section"},{"location":"pages/Examples/airfoil/","page":"Airfoil","title":"Airfoil","text":"(Image: uniform-metric)","category":"page"},{"location":"pages/Examples/airfoil/#Leading-Edge","page":"Airfoil","title":"Leading Edge","text":"","category":"section"},{"location":"pages/Examples/airfoil/","page":"Airfoil","title":"Airfoil","text":"(Image: leading-metric)","category":"page"},{"location":"pages/Examples/airfoil/#Trailing-Edge","page":"Airfoil","title":"Trailing Edge","text":"","category":"section"},{"location":"pages/Examples/airfoil/","page":"Airfoil","title":"Airfoil","text":"(Image: trialing-metric)","category":"page"},{"location":"pages/Examples/airfoil/#Leading-and-Trailing-Edge","page":"Airfoil","title":"Leading and Trailing Edge","text":"","category":"section"},{"location":"pages/Examples/airfoil/","page":"Airfoil","title":"Airfoil","text":"(Image: leadingandtrailing-metric)","category":"page"},{"location":"pages/Examples/airfoil/#Custom-Metric","page":"Airfoil","title":"Custom Metric","text":"","category":"section"},{"location":"pages/Examples/airfoil/","page":"Airfoil","title":"Airfoil","text":"(Image: custom-metric)","category":"page"},{"location":"pages/2Dto1D/Mapping2Dto1D/#Mapping-the-2-Dimensional-Problem-to-1-Dimension","page":"Mapping 2D to 1D","title":"Mapping the 2 Dimensional Problem to 1 Dimension","text":"","category":"section"},{"location":"pages/2Dto1D/Mapping2Dto1D/","page":"Mapping 2D to 1D","title":"Mapping 2D to 1D","text":"Since we aim to construct grid in Omega subset R^2, we need a method to convert the 2D problem into a 1D problem. While we have the 1D equation","category":"page"},{"location":"pages/2Dto1D/Mapping2Dto1D/","page":"Mapping 2D to 1D","title":"Mapping 2D to 1D","text":"beginalign*\n-8 sigma^4 M^2 x_s^2  x_ss - 4 sigma^4 M M_x x_s^4  -  4  sigma^2 m M x_ss  -  2 sigma^2 m M_x x_s^2  = 0\nendalign*","category":"page"},{"location":"pages/2Dto1D/Mapping2Dto1D/","page":"Mapping 2D to 1D","title":"Mapping 2D to 1D","text":"we need to reduce the dimension of x in R^2 and M in R^2 times 2. This will consistent of four steps:","category":"page"},{"location":"pages/2Dto1D/Mapping2Dto1D/","page":"Mapping 2D to 1D","title":"Mapping 2D to 1D","text":"Convert the 2D metric to 1D\nConvert the 2D curve to 1D\nNumerically solve the Spacing ODE\nConvert 1D distribution of points back to curve","category":"page"},{"location":"pages/2Dto1D/Mapping2Dto1D/#Results","page":"Mapping 2D to 1D","title":"Results","text":"","category":"section"},{"location":"pages/2Dto1D/Mapping2Dto1D/","page":"Mapping 2D to 1D","title":"Mapping 2D to 1D","text":"Putting everything together and using the analytical solver, we get the following results:","category":"page"},{"location":"pages/2Dto1D/Mapping2Dto1D/#Uniform.","page":"Mapping 2D to 1D","title":"Uniform.","text":"","category":"section"},{"location":"pages/2Dto1D/Mapping2Dto1D/","page":"Mapping 2D to 1D","title":"Mapping 2D to 1D","text":"(Image: uniform)","category":"page"},{"location":"pages/2Dto1D/Mapping2Dto1D/#Clustering-at-x0.0","page":"Mapping 2D to 1D","title":"Clustering at x=00","text":"","category":"section"},{"location":"pages/2Dto1D/Mapping2Dto1D/","page":"Mapping 2D to 1D","title":"Mapping 2D to 1D","text":"(Image: x=0)","category":"page"},{"location":"pages/2Dto1D/Mapping2Dto1D/","page":"Mapping 2D to 1D","title":"Mapping 2D to 1D","text":"Example with sparse sampling of the airfoil:","category":"page"},{"location":"pages/2Dto1D/Mapping2Dto1D/","page":"Mapping 2D to 1D","title":"Mapping 2D to 1D","text":"(Image: x=0)","category":"page"},{"location":"pages/2Dto1D/Mapping2Dto1D/#Clustering-at-x1","page":"Mapping 2D to 1D","title":"Clustering at x=1","text":"","category":"section"},{"location":"pages/2Dto1D/Mapping2Dto1D/","page":"Mapping 2D to 1D","title":"Mapping 2D to 1D","text":"(Image: x=1)","category":"page"},{"location":"pages/2Dto1D/Mapping2Dto1D/","page":"Mapping 2D to 1D","title":"Mapping 2D to 1D","text":"Zooming in on the leading edge of the airfoil, we see a potential issue: the solution boundary is no longer aligned with the real boundary:","category":"page"},{"location":"pages/2Dto1D/Mapping2Dto1D/","page":"Mapping 2D to 1D","title":"Mapping 2D to 1D","text":"(Image: x=1)","category":"page"},{"location":"pages/2Dto1D/Mapping2Dto1D/#Real-Metric-Data","page":"Mapping 2D to 1D","title":"Real Metric Data","text":"","category":"section"},{"location":"pages/2Dto1D/Mapping2Dto1D/","page":"Mapping 2D to 1D","title":"Mapping 2D to 1D","text":"Here we have real metric data:","category":"page"},{"location":"pages/2Dto1D/Mapping2Dto1D/","page":"Mapping 2D to 1D","title":"Mapping 2D to 1D","text":"(Image: real-metric)","category":"page"},{"location":"pages/2Dto1D/Mapping2Dto1D/","page":"Mapping 2D to 1D","title":"Mapping 2D to 1D","text":"Since the spacing of the points is hard to see, the difference of the 1D points is plotted in red. ","category":"page"},{"location":"pages/2Dto1D/Mapping2Dto1D/","page":"Mapping 2D to 1D","title":"Mapping 2D to 1D","text":"Here we show real metric data but scaled down by 0001:","category":"page"},{"location":"pages/2Dto1D/Mapping2Dto1D/","page":"Mapping 2D to 1D","title":"Mapping 2D to 1D","text":"(Image: real-metric)","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/#Numerical-Methods-First-Order-System","page":"First Order System","title":"Numerical Methods - First Order System","text":"","category":"section"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"We wish to solve the ODE","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"boxed8 sigma^4  M^2 x_s^2 x_ss  + 4 sigma^4  M M_x x_s^4 + 4sigma^2 m^2 M x_ss + 2 sigma^2 m M_x x_s^2  = 0","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"We aim to solve the system of first order nonlinear boundary value odes. Let's use DifferentialEquations.jl to try and solve the ODE with low effort.","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/#Formulation","page":"First Order System","title":"Formulation","text":"","category":"section"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"Let u_1 = x and u_2 = x_s to find","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"begincases \nu_1 = u_2 = x\nu_2 = x = - frac12 fracM_xM x_s^2\nendcases","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"with dirichlet boundary conditions:","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"u_1(1) = x_1 u_1(0) = x_0","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"Mathematical work shown here.","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/#Numerical-Solver","page":"First Order System","title":"Numerical Solver","text":"","category":"section"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"We can set up the problem like this","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"# Spacing ODE\nfunction SpacingODE!(du, u, p, s)\n    M_u1_func, M_func, sigma, _, _ = p\n    u1, u2 = u\n\n    M_u1 = M_u1_func(u1)\n    M = M_func(u1)\n\n    du[1] = u2\n    du[2] = - (M_u1 * u2^2) / (2 * M)    \nend\n\n\n# Set the boundary conditions\nfunction BoundaryConditions!(residual, u, p, s)\n    _, _, _, x0, x1 = p\n    residual[1] = u[1][1] - x0\n    residual[2] = u[end][1] - x1\nend","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"Now as the user we can define the metric function and derivative (analytically for now) and solve the spacing","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"using GridGeneration\n\n# define metric and derivative\nscale = 8000\nM(x) = scale * (1 + 15 * (x))^(-2)\nM_u1(x) = -2 * scale * (1 + 15 * (x))^(-3) * (15)\n\n# boundary values\nx0 = 0.0\nx1 = 1.0\n\n# define number of grid points\nN = 100\n\n# pass to the numerical solver\nsol = GridGeneration.SolveODE(M, M_u1, N, x0, x1);","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/#Results","page":"First Order System","title":"Results","text":"","category":"section"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"Let's compare the distribution of points for four different metrics","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"Uniform: M_1(x) = alpha\nClustering at x=00: M_2(x) =  fracalpha(1 + 15x)^2\nClustering at x=1: M_3(x) =  fracalpha(1 + 15(1-x))^2\nClustering at x=05: M_4(x) = alpha textexpleft( frac-(x - 05)^2etaright)\nClustering at the edges: M_5(x) = M_2(x) + M_3(x) ","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"where alpha and beta are parameters.","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"Here are the results for the numerical approach with alpha = 40000 and beta = 005. With the last two examples, we are already running into the solver not being able to handel the stiffness of the problem.","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/#Uniform","page":"First Order System","title":"Uniform","text":"","category":"section"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"(Image: Uniform)","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/#Clustering-Near-x0","page":"First Order System","title":"Clustering Near x=0","text":"","category":"section"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"(Image: x=0 clustering)","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/#Clustering-Near-x1","page":"First Order System","title":"Clustering Near x=1","text":"","category":"section"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"(Image: x=1 clustering)","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/#Clustering-Near-x0.5","page":"First Order System","title":"Clustering Near x=05","text":"","category":"section"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"(Image: x=0.5 clustering)","category":"page"},{"location":"pages/NumericalMethods/FirstOrderSystem/#Clustering-Near-Edges","page":"First Order System","title":"Clustering Near Edges","text":"","category":"section"},{"location":"pages/NumericalMethods/FirstOrderSystem/","page":"First Order System","title":"First Order System","text":"(Image: edge clustering)","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/#Second-Order-Nonlinear-ODE-Boundary-Value-Solver","page":"Second Order BVP ODE","title":"Second Order Nonlinear ODE Boundary Value Solver","text":"","category":"section"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"we have the ODE","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"x_ss + frac M_x x_s^22M = 0","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"with boundary values x(0) = a and x(1) = b from math work. Let f(x) = fracM_x2 M to get","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"x_ss + f(x) x_s^2 = 0","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":".","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/#Numerical-Method","page":"Second Order BVP ODE","title":"Numerical Method","text":"","category":"section"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"Let x_i_i=0^N+1 be a discretization of a b with uniform grid spacing h. Let's discretizing x_ss and x_s via a second order central difference:","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"x_s = fracx_i+1 - x_i-12h quad x_ss = fracx_i-1 - 2x_i + x_i+1h^2","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"where h = Delta x. Plugging this into the ODE yields the ith equation to be","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"frac1h^2 left(x_i-1 - 2x_i + x_i+1right) + fracf_i4 h^2 left(x_i+1 - x_i-1 right)^2 = 0","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":".","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"Now let's use an iterative method to solve for the nonlinearity. Now on the k+1th iteration, we treat the nonlinear terms as known from the kth iteration to get","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"frac1h^2 left(x_i-1^(k+1) - 2x_i^(k+1) + x_i+1^(k+1)right) = - fracf_i^(k)4 h^2 left(x_i+1^(k) - x_i-1^(k) right)^2","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":".","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"This is a tri-diagonal system which we can solve with Thomas's algorithm on each iteration. We can formulate the system as","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"frac1h^2beginpmatrix \n-2  1 0\n1  - 2  1 \n ddots  ddots  ddots\n    1  -2 1\n0     1  -2\nendpmatrix beginpmatrix x^(k+1)_1  x^(k+1)_2  vdots   x^(k+1)_N-1  x^(k+1)_N endpmatrix = beginpmatrix -fracf_1^(k)4h^2 left( x_2^(k) - x_0 right)^2 - fracx_0h^2  -fracf_2^(k)4h^2 left( x_3^(k) - x_1^(k) right)^2  vdots  -fracf_N-1^(k)4h^2 left( x_N^(k) - x_N-2^(k) right)^2  -fracf_N^(k)4h^2 left( x_N+1^(k) - x_N-1^(k) right)^2 - fracx_N+1h^2 endpmatrix","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"where we can enforce the boundary conditions through x_0 = a and x_N+1 = b. For us, we will have a=0 and b=1.","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/#Algorithms","page":"Second Order BVP ODE","title":"Algorithms","text":"","category":"section"},{"location":"pages/NumericalMethods/SecondOrderBVP/#Thomas-Algorithm","page":"Second Order BVP ODE","title":"Thomas Algorithm","text":"","category":"section"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"A very straightforward guy","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"function thomas_algorithm(a, b, c, d)\n    n = length(d)\n    cp = similar(c)\n    dp = similar(d)\n\n    # forward sweep\n    cp[1] = c[1] / b[1]\n    dp[1] = d[1] / b[1]\n\n    for i in 2:n\n        denom = b[i] - a[i] * cp[i-1]\n        cp[i] = c[i] / denom\n        dp[i] = (d[i] - a[i] * dp[i-1]) / denom\n    end\n\n    # backward substitution\n    x = zeros(n)\n    x[end] = dp[end]\n    for i = n-1:-1:1\n        x[i] = dp[i] - cp[i] * x[i+1]\n    end\n\n    return x\nend","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/#Solver","page":"Second Order BVP ODE","title":"Solver","text":"","category":"section"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"With this in hand, we set up the solver","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"function solve_bvp_fixed_point(f, x0, x1; N=100, max_iter=100, tol=1e-8)\n    function normInf(x)\n        return maximum(abs, x)\n    end\n    \n    h = 1.0 / (N + 1)\n    x = range(0, 1, length=N+2)\n\n    u = [x0; collect(x[2:end-1]); x1]  # initial guess: linear\n\n    println(size(u))\n\n    u_new = similar(u)\n\n    # Storage for tridiagonal matrix\n    a = fill(1 / h^2, N)    # subdiagonal\n    b = fill(-2 / h^2, N)   # diagonal\n    c = fill(1 / h^2, N)    # superdiagonal\n    rhs = zeros(N)\n\n    for iter in 1:max_iter\n        for i in 1:N\n            fi = f(u[i+1])\n\n            du = u[i+2] - u[i]\n            \n            rhs[i] = - (fi / (4h^2)) * du^2\n        end\n        rhs[1] += - x0 / h^2\n        rhs[end] += - x1 / h^2\n\n\n        # Solve linear system\n        δu = thomas_algorithm(a, b, c, rhs)\n\n        # Update interior points\n        u_new[1] = x0\n        u_new[end] = x1\n        u_new[2:N+1] = δu\n\n        # Check convergence\n        if normInf(u_new - u) < tol\n            println(\"Converged in $iter iterations\")\n            return x, u_new\n        end\n\n        u .= u_new\n    end\n\n    error(\"Did not converge after $max_iter iterations.\")\nend","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"Note here that f is expecting a function. We can use our piecewise linear interpolator to take the discrete points given by M_x(x_i)(2M(x_i)) where M_x is approximated through central differences. ","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"Another note is that if we start struggling to solve this, we can always add relaxation to the updates.","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"We can define the RHS as ","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"function f(x, scale, problem)\n    return (M_u1_func(x,) / (2 * M_func(x,)))\nend","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/#Under-Relaxation","page":"Second Order BVP ODE","title":"Under Relaxation","text":"","category":"section"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"We run into numerical instability pretty quickly. For example, using ","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"M(x) = fracalpha(1 + 15x)^2","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"with alpha = 40000 and N in 5 50 100 500. We have the algorithm terminate after 100 iterations or if the infinity norm of the residual drops below 1e-15. This gives the following results","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"(Image: )","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"We can see the numerical instability in the convergence plot and solution.","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"Let's use under-relaxation to update u:","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"#omega is relaxation parameter.\nu .= (1 - omega) * u + omega * u_new","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"Note that omega = 1 is equivalent to before. Now running with omega = 05 we get the results which look a lot better:","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"(Image: )","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"Furthermore, running with s = 100000 yields","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"(Image: )","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/#Verification","page":"Second Order BVP ODE","title":"Verification","text":"","category":"section"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"For now, let's go ahead and use this since the solution passes the \"eye-norm.\"","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/#Order-of-Convergence","page":"Second Order BVP ODE","title":"Order of Convergence","text":"","category":"section"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"This method should be second order accurate.","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/#Method-of-Manufactured-Solutions","page":"Second Order BVP ODE","title":"Method of Manufactured Solutions","text":"","category":"section"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"We could use manufactured solutions.","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/#Results","page":"Second Order BVP ODE","title":"Results","text":"","category":"section"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"Let's compare the distribution of points for four different metrics","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"Uniform: M_1(x) = alpha\nClustering at x=00: M_2(x) =  fracalpha(1 + 15x)^2\nClustering at x=1: M_3(x) =  fracalpha(1 + 15(1-x))^2\nClustering at x=05: M_4(x) = alpha textexpleft( frac-(x - 05)^2etaright)\nClustering at the edges: M_5(x) = M_2(x) + M_3(x) ","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"where alpha and beta are parameters.","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"Here are the results for the numerical approach with alpha = 40000 and beta = 01. With the last two examples, we are already running into the solver not being able to handel the stiffness of the problem. We note that convergence plots are not the most telling since in all cases, the norm of the error reduces to machine precision.","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/#Uniform","page":"Second Order BVP ODE","title":"Uniform","text":"","category":"section"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"(Image: Uniform)","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/#Clustering-Near-x0","page":"Second Order BVP ODE","title":"Clustering Near x=0","text":"","category":"section"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"(Image: x=0 clustering)","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/#Clustering-Near-x1","page":"Second Order BVP ODE","title":"Clustering Near x=1","text":"","category":"section"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"(Image: x=1 clustering)","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/#Clustering-Near-x0.5","page":"Second Order BVP ODE","title":"Clustering Near x=05","text":"","category":"section"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"(Image: x=0.5 clustering)","category":"page"},{"location":"pages/NumericalMethods/SecondOrderBVP/#Clustering-Near-Edges","page":"Second Order BVP ODE","title":"Clustering Near Edges","text":"","category":"section"},{"location":"pages/NumericalMethods/SecondOrderBVP/","page":"Second Order BVP ODE","title":"Second Order BVP ODE","text":"(Image: edge clustering)","category":"page"},{"location":"pages/2Dto1D/PointProjection/#Projecting-Points","page":"Projecting Points","title":"Projecting Points","text":"","category":"section"},{"location":"pages/2Dto1D/PointProjection/#2D-to-1D-Projection","page":"Projecting Points","title":"2D to 1D Projection","text":"","category":"section"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"Suppose we wish to solve the grid spacing along a discrete boundary Gamma given by the points gamma_i in R^2 for i=12dots n where n is the total number of points along the boundary. In-between each point is a linear interpolation Gamma_i for i=12dotsn-1 which defines the piecewise-continuous boundary Gamma. That is","category":"page"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"Gamma(x) = begincases Gamma_i(eta_i(x)) textif  x in gamma_i gamma_i+1  0 textotherwise endcases","category":"page"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"where","category":"page"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"Gamma_i(eta) = eta gamma_i+1 + (1 - eta) gamma_i quad eta in 01","category":"page"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"Here eta_i(x) would be a parameterization between gamma_i and gamma_i+1. That is ","category":"page"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"eta_i(x) = fracx - gamma_igamma_i+1 - gamma_i","category":"page"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"Okay writing this out mathematically is a pain, let's just explain the algorithm.","category":"page"},{"location":"pages/2Dto1D/PointProjection/#Algorithm","page":"Projecting Points","title":"Algorithm","text":"","category":"section"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"Given gamma_i in R^2, find a 1D representation s in R. We want to do this in such a way that we can find an invertible mapping f R^2 to R. Now with f(Gamma_i) in R and m in R, we can solve the spacing ODE to get the optimal distribution xi_i. Finally we can project the points back onto the Gamma_i to get the optimal distribution on the boundary using f^-1.","category":"page"},{"location":"pages/2Dto1D/PointProjection/#Basic-Method-in-Words","page":"Projecting Points","title":"Basic Method in Words","text":"","category":"section"},{"location":"pages/2Dto1D/PointProjection/#Step-1-2D-to-1D","page":"Projecting Points","title":"Step 1 - 2D to 1D","text":"","category":"section"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"Given points  gamma_i _i=1^n we can  f(gamma_i) _i=1^n by ","category":"page"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"Computing the local spacing in array diff,\nAccumulate the spacing sp = cumsum(diff),\nAdd zero back in xi = [0, sp],\nNormalize xs = xi / xi[end].","category":"page"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"Now  textxs _i=1^n is within 01 with normalized spacing according to the original boundary spacing. Algorithmically:","category":"page"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"function Boundary2Dto1D(boundary)\n    # boundarySection is 2×N (rows: x,y; columns: points in order)\n    x = boundary[1, :]\n    y = boundary[2, :]\n\n    # segment lengths (N-1)\n    Δx = diff(x)\n    Δy = diff(y)\n    Δs = sqrt.(Δx.^2 .+ Δy.^2)\n\n    xs = [0.0; cumsum(Δs)]   # length N, xs[1]=0, xs[end]=arclength\n\n    # normalize \n    xs = xs ./ xs[end]  # now xs is in [0, 1]\n    return xs\nend","category":"page"},{"location":"pages/2Dto1D/PointProjection/#Step-2-Spacing","page":"Projecting Points","title":"Step 2 - Spacing","text":"","category":"section"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"Now we get the optimal spacing","category":"page"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"Compute non-optimal solution sol = GridGeneration.SolveODE(M, Mx, N, xs[1], xs[end])\nCompute optimal spacing N_opt = ceil(Int, 1 / GridGeneration.ComputeOptimalSpacing(sol[1, :], M, xs))\nCompute optimal solution sol_opt = GridGeneration.SolveODE(M, Mx, N_opt, xs[1], xs[end])  ","category":"page"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"function GetOptimalSolution(m, mx, N, xs; method = \"system of odes\")\n    m_func = GridGeneration.build_interps_linear(xs, m)\n    mx_func = GridGeneration.build_interps_linear(xs, mx)\n\n    if method == \"system of odes\"\n        sol = GridGeneration.SolveODE(m_func, mx_func, N, xs[1], xs[end])\n        N_opt = GridGeneration.ComputeOptimalNumberofPoints(sol[1, :], m, xs)\n        @info(\"Optimal number of points: \", N_opt)\n        sol_opt = GridGeneration.SolveODE(m_func, mx_func, N_opt, xs[1], xs[end])\n    end\n\n    return sol_opt, sol\nend","category":"page"},{"location":"pages/2Dto1D/PointProjection/#Step-3-1D-to-2D","page":"Projecting Points","title":"Step 3 - 1D to 2D","text":"","category":"section"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"And finally let's project the points back onto the boundary","category":"page"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"Extract solution x_sol = sol_opt[1,:]\nFor each x in x_sol\ndetermine i such that x in textxs_i textxs_i+1\ncompute eta = fracx - textxs_itextxs_i+1 - textxs_i\nInterpolate x onto Gamma_i according to eta","category":"page"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"The algorithm for this can be pretty straightforward if we assert that the incoming xs is increasing. We have already taken care of that. Let's also add clamping to the edges to make sure that the start and ending points don't move.","category":"page"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"function ProjectBoundary1Dto2D(boundary, points, xs)\n    projectedPoints = zeros(2, length(xs))\n    for (i, pnt) in enumrate(points)\n        intervalIndex = FindContainingIntervalIndex(pnt, xs)\n        dist = pnt - xs[intervalIndex]\n        normalDist = dist / (xs[intervalIndex + 1] - xs[intervalIndex])\n        projectPoint = ProjectPointOntoBoundary(normalDist, intervalIndex, boundary)\n        projectedPoints[i] = projectPoint\n    end\n    return projectedPoints\nend","category":"page"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"with the two helper functions","category":"page"},{"location":"pages/2Dto1D/PointProjection/","page":"Projecting Points","title":"Projecting Points","text":"function FindContainingIntervalIndex(pnt, dist)\n    # assert that dist is increasing\n    index = - 1\n    \n    # clamp\n    if pnt < dist[1]\n        index = 1\n    end\n\n    if pnt > dist[end]\n        index = length(dist) - 1\n    end\n\n    for (i,d) in enumerate(dist)\n        if d > pnt\n            index = i - 1\n        end\n    end\n\n    return index\nend\n\nfunction ProjectPointOntoBoundary(s, ind, boundary)\n    # interpolate boundary[ind] and boundary[ind + 1] with s\n    projectedPoint = s * boundary[ind] + (1 - s) * boundary[ind+1]\n    return projectPoint\nend\n","category":"page"},{"location":"pages/ODE/MathematicalWork/#Mathematical-Work","page":"Mathematical Work","title":"Mathematical Work","text":"","category":"section"},{"location":"pages/ODE/MathematicalWork/#PDE-Formulation","page":"Mathematical Work","title":"PDE Formulation","text":"","category":"section"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"We define the metric","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"m_alpha(x_s x s) = sigma_alpha^2  M x_s^2 - 1","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"where M(x(s)) is the metric tensor field designed from the residual posterior estimate, x is the physical domain and s is the computational domain. We will use variable subscripts to notation derivatives left( x_s = fracdxds right). Next, we define our loss as ","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"L_textmisfit(x_s x s) = m_alpha^2","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"which we use to define the functional  ","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"mathcalLx(s) = int_Omega L(x(s) x_s(s) s) d s","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"From variations we know the general solution is the Euler-Lagrange equation","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"fracpartial Lpartial x- fracdd s fracpartial Lpartial x_s = 0","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"For this choice of kernel L_textmisfit, the solution in R^n is a second-order nonlinear PDE of the form","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"-sum_alpha=1^n 8 sigma_alpha^4 M_klfracpartial x_lpartial s_alpha M_ij fracpartial x_ipartial s_alpha fracpartial^2 x_jpartial s_alpha^2 - sum_alpha = 1^n 4 sigma_alpha^4 M_kl fracpartial x_lpartial s_alphafracpartial M_ijpartial x_p fracpartial x_ppartial s_alpha fracpartial x_ipartial s_alpha fracpartial x_jpartial s_alpha - sum_alpha=1^n m_alpha sigma_alpha^2left( 4 M_kj fracpartial^2 x_jpartial s_alpha^2 + 4 fracpartial M_kjpartial x_pfracpartial x_ppartial x_s fracpartial x_jpartial s_alpha  - 2 fracpartial M_ijpartial x_kfracpartial x_ipartial s_alpha  fracpartial x_jpartial s_alpha right) = 0 k in 1 2 dots n","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"where Einstein Notation is used for non-Greek subscripts. ","category":"page"},{"location":"pages/ODE/MathematicalWork/#ODE-Formulation","page":"Mathematical Work","title":"ODE Formulation","text":"","category":"section"},{"location":"pages/ODE/MathematicalWork/#Second-Order-Nonlinear-ODE","page":"Mathematical Work","title":"Second Order Nonlinear ODE","text":"","category":"section"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"In one dimension, we can clean up the above equation notably by removing all the summations and indices:","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"beginalign*\n-8 sigma^4 Mfracpartial xpartial s M fracpartial xpartial s fracpartial^2 xpartial s^2 - 4 sigma^4 M fracpartial xpartial sfracpartial Mpartial x fracpartial xpartial sfracpartial xpartial s fracpartial xpartial s -  m sigma^2left( 4 Mfracpartial^2 xpartial s^2 + 4 fracpartial Mpartial xfracpartial xpartial sfracpartial xpartial s  - 2 fracpartial Mpartial xfracpartial xpartial s  fracpartial xpartial s right) = 0\nendalign*","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"Let's combine like terms, fully expand, and introduce the subscript notation for partial derivatives","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"beginalign*\n-8 sigma^4 M^2 x_s^2  x_ss - 4 sigma^4 M M_x x_s^4  -  4  sigma^2 m M x_ss  -  2 sigma^2 m M_x x_s^2  = 0\nendalign*","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"which is our second order nonlinear ODE.","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"Working towards a first order system, let's simplify by dividing both sides by -2 sigma^2 to get","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"beginalign*\n4 sigma^2 M^2 x_s^2  x_ss + 2 sigma^2 M M_x x_s^4  +  2  m M x_ss  +  m M_x x_s^2  = 0\nendalign*","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"Now let's solve for x_ss to find","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"beginalign*\nleft( 4 sigma^2 M^2 x_s^2 + 2 m M right) x_ss + 2 sigma^2 M M_x x_s^4 +  m M_x x_s^2  = 0 iff x_ss = - frac2 sigma^2 M M_x x_s^4 +  m M_x x_s^24 sigma^2 M^2 x_s^2 + 2 m M\nendalign*","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"Further simplifying we arrive at","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"beginalign*\nx_ss = - frac M_x x_s^2 left( 2sigma^2 M x_s^2 +  m right)2M left( 2sigma^2 M x_s^2 + mright) = - frac M_x x_s^22M\nendalign*","category":"page"},{"location":"pages/ODE/MathematicalWork/#First-Order-System","page":"Mathematical Work","title":"First Order System","text":"","category":"section"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"To turn the above into a first order system, let u_1 = x and u_2 = x_s, then","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"begincases \nu_1 = u_2 = x\nu_2 = x = - frac12 fracM_xM x_s^2\nendcases","category":"page"},{"location":"pages/ODE/MathematicalWork/#Semi-Analytic-Solution","page":"Mathematical Work","title":"Semi-Analytic Solution","text":"","category":"section"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"We can continue to simplify by letting u = x_s, then we arrive at","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"x_ss = - frac M_x x_s^22M implies fracd ud s = - frac12 fracM_xM u^2","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"Now expanding the chain rule we get that","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"fracd ud s = fracd ud x fracdxds = fracdudx u","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"and so we can write","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"\nfracdudx = - frac12 fracM_xM u\n\n\nIf we assume that x_s neq 0","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":", we can divide both sides by u and integrate to find that","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"ln( u ) = - frac12 ln(M) iff u =  fracdxds = x_s = fracC_1sqrtM(x)","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"where C_1 comes from the constant of integration. ","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"We have an initial value boundary value problem (IVBP ODE), so let's prescribe boundary conditions at x(s=0) = 0 and x(s=1) = L such that our computational domain is s in 01 and the physical domain is x in 0L subset R.","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"Next, let's separate variables to get","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"fracdxds = fracC_1sqrtM(x) rightarrow sqrtM(x) dx = C_1 ds","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"Integrating both sides from s=0 to s, ","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"int_x(0)^x(s) sqrtM(xi) dxi = C_1 s","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"Finally let's enforce the boundary condition at x(1) = L to solve for C_1 and find that","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"C_1 = int_0^L sqrtM(xi) d xi","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"Therefore the final solution becomes","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"int_0^x(s) sqrtM(xi) dxi = I(L) s","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"If we let I(x) = int_0^x sqrtM(xi) d xi, we can further clean up the express as","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"I(x(s)) = s I(x(s=1)) implies x(s) = I^-1left( s cdot I(L) right)","category":"page"},{"location":"pages/ODE/MathematicalWork/","page":"Mathematical Work","title":"Mathematical Work","text":"if the inverse of I exists.","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/#Semi-Analytic-Solution","page":"Semi-Analytical Method","title":"Semi Analytic Solution","text":"","category":"section"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/#Set-up","page":"Semi-Analytical Method","title":"Set up","text":"","category":"section"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"As shown in math work, we can reduce the ODE to","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"We have an initial value boundary value problem (IVBP ODE), so let's prescribe boundary conditions at x(s=0) = 0 and x(s=1) = 1 such that our computational domain is s in 01 and the physical domain is x in 01 subset R.","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"I(x) = int_x(0)^x(s) sqrtM(xi) dxi = C_1 s","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"Finally let's enforce the boundary condition at x(1) = 1 to solve for C_1 and find that","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"C_1 = int_0^1 sqrtM(xi) d xi = I_texttot","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"Therefore the final solution becomes","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"int_0^x(s) sqrtM(xi) dxi = I_texttot s","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"Now since the form of M(x(s)) is \"not known\" but rather is given as discrete points, integrating must be done numerically. We do know that M is SPD and so ","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"l^top M l geq 0 forall l","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"Since we are approximating M in R^2 times 2 by m = l^top M l in R, we are ensured that sqrt(m) will be positive. This implies that I(x) is monotone increasing (modulo edge cases). To compute I^-1(x), let's use linear interpolation. We can later try using \"monotone cubic Hermite\" (PCHIP).","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/#Algorithm","page":"Semi-Analytical Method","title":"Algorithm","text":"","category":"section"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"Since the real function of M(x) is unknown, let's use trapezoid rule to integrate. Then the algorithm will follow the steps","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"Compute I(x) via trapezoid rule.\nCompute l = I(1).\nSolve I(x) = s * I(1)\nLinear Interpolation\nmonotone cubic Hermite (PCHIP)\nHigher order interpolation","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/#Linear-Interpolation","page":"Semi-Analytical Method","title":"Linear Interpolation","text":"","category":"section"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"If we assume that I(x) is given by piecewise linear functions between nodal values, than ","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"I(x) approx I_i + fracI_i+1 - I_ix_i+1 - x_i (x - x_i+1)","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"Since we have our trapezoidal approximation we can write I(x) approx t_j and solving for x now gives","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"theta = fract_j - I_iI_i+1 - I_i in 01 quad x_j = x_i + theta (x_i+1 - x_i)","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"where we can numerically find i using a binary search which is helpfully defined in Julia as searchsortedlast(dist, pnt).","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"function equidistribute_linear_inverse(x, m, N)\n    @assert length(x) == length(m) \"x and m must have same length\"\n    @assert isapprox(first(x), 0.0; atol=1e-12) && isapprox(last(x), 1.0; atol=1e-12)\n    @assert issorted(x) \"x must be strictly increasing\"\n    @assert minimum(m) >= 0.\n\n    n = length(x) - 1\n    Δx = x[2:end] .- x[1:end-1]\n    w  = sqrt.(max.(m))  # √m\n\n    # cumulative trapezoid\n    I = similar(x, Float64)\n    I[1] = 0.0\n    for i in 1:n\n        I[i+1] = I[i] + 0.5*(w[i] + w[i+1]) * Δx[i]\n    end\n    Itot = I[end]\n\n    # uniform s-grid and targets\n    s = range(0.0, 1.0; length=N)\n    t = Itot .* s\n\n    # invert by linear interpolation on (I, x)\n    x_nodes = similar(s, Float64)\n    for (j, tj) in enumerate(t)\n        # find i with I[i] <= tj <= I[i+1]\n        i = searchsortedlast(I, tj)\n        if i == length(I)         # tj == I[end]\n            x_nodes[j] = x[end]\n        elseif I[i+1] == I[i]     # flat segment (m ~ 0)\n            x_nodes[j] = x[i]     # or x[i] + θ*Δx[i] if you want uniform spread\n        else\n            θ = (tj - I[i]) / (I[i+1] - I[i])\n            x_nodes[j] = x[i] + θ * (x[i+1] - x[i])\n        end\n    end\n    return x_nodes\nend","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/#Analytic-Solution","page":"Semi-Analytical Method","title":"Analytic Solution","text":"","category":"section"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"Now if we know M(x), we can carry out the integration and find the solution. Let's do this and use this exact solution as a double check to our numerical solvers.","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/#Example-1","page":"Semi-Analytical Method","title":"Example 1","text":"","category":"section"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"Suppose M(x) = 400 x^2 on the interval 01. We expect clustering near x=1. Plugging this into the solution yields","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"int_0^x(s) sqrt400 xi^2 dxi =  s int_0^1 sqrt400 xi^2 dxi  iff int_0^x(s) 20 xi dxi = s int_0^1 20 xi dxi","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"Letting I(x) = int_0^x(s) sqrtM(xi) d xi we can integrate to find","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"I(x) = 10x^2 implies I(1) = 10","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"Plugging this in we find that","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"10x^2(s) = 10 s implies x_textsol = sqrts","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"Which makes sense as s in 01 would clustered around x=1 under the mapping x_textsol(s).","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/#Results","page":"Semi-Analytical Method","title":"Results","text":"","category":"section"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/#x0-clustering","page":"Semi-Analytical Method","title":"x=0 clustering","text":"","category":"section"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"(Image: x=0)","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/#x1-clustering","page":"Semi-Analytical Method","title":"x=1 clustering","text":"","category":"section"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"(Image: x=0)","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/#x0.5-clustering","page":"Semi-Analytical Method","title":"x=0.5 clustering","text":"","category":"section"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"(Image: x=0)","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/#edge-clustering","page":"Semi-Analytical Method","title":"edge clustering","text":"","category":"section"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"(Image: x=0)","category":"page"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/#edge-and-center-clustering","page":"Semi-Analytical Method","title":"edge and center clustering","text":"","category":"section"},{"location":"pages/NumericalMethods/SemiAnalyticalMethod/","page":"Semi-Analytical Method","title":"Semi-Analytical Method","text":"(Image: x=0)","category":"page"},{"location":"pages/SingleBlock/splitting/#Single-Block-with-Splitting","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"","category":"section"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"Let's make this into two main GridGeneration functions: GridGeneration.SplitBlock(block, splitLocations, bndInfo, interInfo) and GridGeneration.SolveAllBlocks(metric, blocks, bndInfo, interInfo). And thus all we have to do is","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"Input single Tortuga block and desired split locations with the block\nSplit block into multi-block grid and update bndInfo and interInfo\nSolve for the optimal distribution in each block","category":"page"},{"location":"pages/SingleBlock/splitting/#Split-Block-Algorithm","page":"Single Block with Splitting","title":"Split Block Algorithm","text":"","category":"section"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"We want something along the lines:","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"splitLocations = [\n    [ horizontal split indices... ],   # split along the x axis\n    [ vertical split indices... ]      # split along the y axis\n]\n\nblocks, bndInfo, interInfo = GridGeneration.SplitBlock(block, splitLocations, bndInfo, interInfo)","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"where the SplitBlock function ","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"function SplitBlock(block, splitLocations, bndInfo, interInfo)\n    blocks = []\n    horzSplits = [1, splitLocations[1]..., size(block, 2)]\n    vertSplits = [1, splitLocations[2]..., size(block, 3)]\n\n    parentni = size(block, 2)\n    parentnj = size(block, 3)\n    parentnk = 1\n\n    blockId = 1\n    blockBoundaries = []\n    interfaces = []\n    for j in 1:length(vertSplits)-1\n        for i in 1:length(horzSplits)-1\n            ni = horzSplits[i+1] - horzSplits[i] + 1\n            nj = vertSplits[j+1] - vertSplits[j] + 1\n            nk = 1\n            \n            subblock = block[:, horzSplits[i]:horzSplits[i+1], vertSplits[j]:vertSplits[j+1]]\n            push!(blocks, subblock) \n\n            # get boundary info \n            blockInfo = Dict(\n                \"block\" => blockId,\n                \"start\" => (horzSplits[i], vertSplits[j]),\n                \"end\" => (horzSplits[i+1], vertSplits[j+1]),\n                \"parentDims\" => (parentni, parentnj, parentnk)\n            )\n\n            boundaries = GetTouchingBoundaries(blockInfo, bndInfo)\n            append!(blockBoundaries, boundaries)\n            \n            # get interface info\n            # if not at the end, look forward to the next block\n            if i < length(horzSplits) - 1\n                blockBId = blockId + 1\n                # println(\"blockID: \", blockId, \" next blockID: \", blockBId)\n                push!(interInfo, Dict(\n                    \"blockA\" => blockId, \"start_blkA\" => [ni,1,1], \"end_blkA\" => [ni,nj,nk],\n                    \"blockB\" => blockBId, \"start_blkB\" => [1,1,1], \"end_blkB\" => [1,nj,nk],\n                    \"offset\" => [0.0, 0.0, 0.0], \"angle\" => 0.0))\n            end\n\n            # if not at top, look up\n            if j < length(vertSplits) - 1\n                blockBId = blockId + length(horzSplits) - 1\n                # println(\"blockID: \", blockId, \" next blockID: \", blockBId)\n                push!(interInfo, Dict(\n                    \"blockA\" => blockId, \"start_blkA\" => [1,nj,1], \"end_blkA\" => [ni,nj,nk],\n                    \"blockB\" => blockBId, \"start_blkB\" => [1,1,1], \"end_blkB\" => [ni,1,nk],\n                    \"offset\" => [0.0, 0.0, 0.0], \"angle\" => 0.0))\n            end\n\n            blockId += 1\n        end\n    end\n    updatedBndInfo = GroupBoundariesByName(blockBoundaries)\n    updatedInterInfo = interfaces\n\n    return blocks, updatedBndInfo, updatedInterInfo\nend","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"with two helper functions GetTouchingBoundaries and GroupBoundariesByName. The former function will take in the block id and the starting and ending indices of the new subblock. ","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"Here we handle the interface info by looking to the right and above.","category":"page"},{"location":"pages/SingleBlock/splitting/#Get-Touching-Boundaries-Idea-1","page":"Single Block with Splitting","title":"Get Touching Boundaries - Idea 1","text":"","category":"section"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"The function will check each of the edges of the child (newly created subblock) to see if they are on the boundary of their parent block (the original block being split). If the edge is on a boundary, inherit the boundary type from parent to child. We can check if the child is on the boundary of the parent by seeing if child start indices are equal to 1 or if the end indices are equal to size of the parent.","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"function GetTouchingBoundaries(blockInfo::Dict, bndInfo)\n    # Parent extents\n    N1, N2, N3 = blockInfo[\"parentDims\"]\n\n    # Child window in parent coordinates (inclusive)\n    i0, j0 = blockInfo[\"start\"]\n    i1, j1 = blockInfo[\"end\"]\n\n    # Child-local sizes\n    ni = i1 - i0 + 1\n    nj = j1 - j0 + 1\n\n    child_id = blockInfo[\"block\"]\n    out = Vector{Dict{String,Any}}()\n\n    # LEFT side of child touches parent's LEFT boundary if i0 == 1\n    if i0 == 1\n        push!(out, Dict(\n            \"block\" => child_id,\n            \"name\"  => getBoundaryNameBySide(bndInfo; side=:left),\n            \"start\" => [1, 1, 1],\n            \"end\"   => [1, nj, 1],\n        ))\n    end\n\n    # RIGHT side of child touches parent's RIGHT boundary if i1 == N1\n    if i1 == N1\n        push!(out, Dict(\n            \"block\" => child_id,\n            \"name\"  => getBoundaryNameBySide(bndInfo; side=:right),\n            \"start\" => [ni, 1, 1],\n            \"end\"   => [ni, nj, 1],\n        ))\n    end\n\n    # BOTTOM side of child touches parent's BOTTOM boundary if j0 == 1\n    if j0 == 1\n        push!(out, Dict(\n            \"block\" => child_id,\n            \"name\"  => getBoundaryNameBySide(bndInfo; side=:bottom),\n            \"start\" => [1, 1, 1],\n            \"end\"   => [ni, 1, 1],\n        ))\n    end\n\n    # TOP side of child touches parent's TOP boundary if j1 == N2\n    if j1 == N2\n        push!(out, Dict(\n            \"block\" => child_id,\n            \"name\"  => getBoundaryNameBySide(bndInfo; side=:top),\n            \"start\" => [1, nj, 1],\n            \"end\"   => [ni, nj, 1],\n        ))\n    end\n\n    return out\nend","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"with the helper function GetBoundaryNameBySide(bndInfo; side=:side) where we take advantage of the fact that bndInfo will only have information about the single inputted block. This function we can write as","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"function GetBoundaryNameBySide(bndInfo; side=:none)\n    \n\n\n\n\nend","category":"page"},{"location":"pages/SingleBlock/splitting/#Get-Touching-Boundaries-Idea-2-(Current)","page":"Single Block with Splitting","title":"Get Touching Boundaries - Idea 2 (Current)","text":"","category":"section"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"Another option is to use this old existing function of mine:","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"function GetTouchingBoundaries(block::Dict, bndInfo)\n    # Child window in parent (global) coordinates, inclusive\n    block_i1, block_j1 = block[\"start\"]\n    block_i2, block_j2 = block[\"end\"]\n    blockId = block[\"block\"]\n\n    # Global -> child-local index maps\n    to_local_i(i) = i - block_i1 + 1\n    to_local_j(j) = j - block_j1 + 1\n\n    touchingFaces = Vector{Dict{String,Any}}()\n\n    for bnd in bndInfo\n        name = bnd[\"name\"]\n        for face in bnd[\"faces\"]\n            faceStart = face[\"start\"];  faceEnd = face[\"end\"]\n            i1, j1 = faceStart[1], faceStart[2]\n            i2, j2 = faceEnd[1],   faceEnd[2]\n\n            # Vertical face on parent's left/right boundary?\n            if i1 == i2 && (i1 == block_i1 || i1 == block_i2)\n                jlo = max(min(j1, j2), block_j1)\n                jhi = min(max(j1, j2), block_j2)\n                if jhi > jlo\n                    push!(touchingFaces, Dict(\n                        \"name\"  => name,\n                        \"block\" => blockId,\n                        \"start\" => [to_local_i(i1), to_local_j(jlo), 1],\n                        \"end\"   => [to_local_i(i2), to_local_j(jhi), 1],\n                    ))\n                end\n\n            # Horizontal face on parent's bottom/top boundary?\n            elseif j1 == j2 && (j1 == block_j1 || j1 == block_j2)\n                ilo = max(min(i1, i2), block_i1)\n                ihi = min(max(i1, i2), block_i2)\n                if ihi > ilo\n                    push!(touchingFaces, Dict(\n                        \"name\"  => name,\n                        \"block\" => blockId,\n                        \"start\" => [to_local_i(ilo), to_local_j(j1), 1],\n                        \"end\"   => [to_local_i(ihi), to_local_j(j2), 1],\n                    ))\n                end\n            end\n        end\n    end\n\n    return touchingFaces\nend","category":"page"},{"location":"pages/SingleBlock/splitting/#Group-Boundaries-by-Name","page":"Single Block with Splitting","title":"Group Boundaries by Name","text":"","category":"section"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"Algorithm reformulates the list of boundaries into the Tortuga format, a list of dicts of dicts, where the first dict is the type of boundary and the sub dict are the blocks and edges.","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"function GroupBoundariesByName(faceList)\n    boundaryGroups = Dict()\n\n    for face in faceList\n        name = face[\"name\"]\n        \n        # Copy face and remove redundant name\n        faceCopy = copy(face)\n        delete!(faceCopy, \"name\")\n        \n        if !haskey(boundaryGroups, name)\n            boundaryGroups[name] = []\n        end\n        push!(boundaryGroups[name], faceCopy)\n    end\n\n    groupedInfo = []\n    for (name, faces) in boundaryGroups\n        if !isempty(faces)\n            push!(groupedInfo, Dict(\"name\" => name, \"faces\" => faces))\n        end\n    end\n\n    return groupedInfo\nend","category":"page"},{"location":"pages/SingleBlock/splitting/#Split-Examples","page":"Single Block with Splitting","title":"Split Examples","text":"","category":"section"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"Inputting the following splits","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"splitLocations = [\n    [ 300, 500 ],   # split along the x axis\n    [ 40 ]      # split along the y axis\n]","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"yields:","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"(Image: test)","category":"page"},{"location":"pages/SingleBlock/splitting/#Solve-All-Blocks-Algorithm","page":"Single Block with Splitting","title":"Solve All Blocks Algorithm","text":"","category":"section"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"With the single block splitting working, let's move to creating an algorithm to solve the ODE across all the edges of the blocks. The challenging part here comes from the required consistency across the edges of the blocks. Consider blocks B_1 with left/right edges e and f and neighboring block B_2 with left/right edges f and g. Now if we solve the ODE along efg and find the optimal number of points (let's denote this via N_e N_f and N_g) are such that N_e  N_f N_g  N_f with N_e neq N_g, then we will have an issue solving along e with the optimal number of points. To fix this issue, we can take the global optimal number N_textopt of the pairs, that is N_textopt = max(N_e N_f N_g) and solve the ef and g edges with N_textopt.","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"Let's have an array blockInstructions of size of blocks that will contain the max number of points in each direction. Now we loop through the blocks and do the following:","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"for each dir\ncollect the neighboring block IDs using the interface info and save in array\nSolve for the number of points for in the dir on both edges\nSend the number of points to each neighbor with the following logic:\nif incoming is greater than saved, overwrite with incoming, else keep the saved value. We can do this by looking at the correct spot in the blockInstructions using the neighboring block Id, and in the correct direction using the current dir. ","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"Once we loop through all blocks, each block should now contain the max number of points to use in each direction. We can finally loop through all the blocks and solve the ODE with the correct number of points.","category":"page"},{"location":"pages/SingleBlock/splitting/#Algorithm","page":"Single Block with Splitting","title":"Algorithm","text":"","category":"section"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"function SolveAllBlocks(metric, blocks, bndInfo, interInfo)\n    blockDirOptN = similar(blocks)\n\n    for i in 1:length(blockDirOptN)\n        blockDirOptN[i] = [-1,-1]\n    end\n\n    # compute max number of points for each block\n    for (blockId, block) in enumerate(blocks)\n        for dir in 1:2  # 1 for horizontal, 2 for vertical\n            blockNeighbors = GetNeighbors(blockId, interInfo, dir; include_start=true)\n            # println(\"blockId: \", blockId, \" dir: \", dir, \" neighbors: \", blockNeighbors)\n\n            #############\n            # method 1\n            #############\n            if dir == 1  # horizontal\n                left   = block[:, 1, :]\n                right  = block[:, end, :]\n                optN = GridGeneration.GetOptNEdgePair(left, right, metric)\n            else  # vertical\n                bottom   = block[:, :, 1]\n                top  = block[:, :, end]\n                optN = GridGeneration.GetOptNEdgePair(bottom, top, metric)\n            end\n\n            # Update the blockDirOptN with the max number of points\n            for computeBlocks in blockNeighbors\n                if blockDirOptN[computeBlocks][dir] < optN\n                    blockDirOptN[computeBlocks][dir] = optN\n                end\n            end\n        end\n    end\n\n    # solve all blocks using the optimal number\n    computedBlocks = similar(blocks)\n    p1 = plot()\n    for (blockId, block) in enumerate(blocks)\n        optNs = blockDirOptN[blockId]\n\n        computedBlock, bndInfo, interInfo = GridGeneration.SolveBlockFixedN(block, bndInfo, interInfo, metric, optNs)\n\n        computedBlocks[blockId] = computedBlock\n    end\n\n    # update the boundary information and interface information \n    GridGeneration.UpdateBndInfo!(bndInfo, computedBlocks; verbose=false)\n    updatedInterInfo = GridGeneration.UpdateInterInfo(interInfo, computedBlocks; verbose=false)\n\n    return computedBlocks, bndInfo, updatedInterInfo\nend\n","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"We can find the neighboring cells in a direction using this recursive function:","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"function GetNeighbors(blockId::Int, interInfo, dir::Int; include_start::Bool=false)\n    seen = Set{Int}()\n\n    function visit(bid::Int)\n        # already visited this block\n        bid ∈ seen && return\n        push!(seen, bid)\n\n        for info in interInfo\n            if info[\"blockA\"] == bid || info[\"blockB\"] == bid\n                # Orientation is defined by the A-side span (shared for both sides)\n                startA = info[\"start_blkA\"]\n                endA   = info[\"end_blkA\"]\n                is_vertical   = (startA[1] != endA[1])\n                is_horizontal = (startA[2] != endA[2])\n\n                if (dir == 2 && is_vertical) || (dir == 1 && is_horizontal)\n                    other = (info[\"blockA\"] == bid) ? info[\"blockB\"] : info[\"blockA\"]\n                    visit(other)\n                end\n            end\n        end\n    end\n\n    visit(blockId)\n\n    return include_start ? collect(seen) : [b for b in seen if b != blockId]\nend","category":"page"},{"location":"pages/SingleBlock/splitting/#Examples","page":"Single Block with Splitting","title":"Examples","text":"","category":"section"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"Putting this all together and using our custom metric creator, we can use the code as follows:","category":"page"},{"location":"pages/SingleBlock/splitting/#Example-1","page":"Single Block with Splitting","title":"Example 1","text":"","category":"section"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"include(\"GridGeneration.jl\")\n\n#################\n# Load in initial single block grid\n#################\n# load in the initial grid - no trailing edge \ninitialGrid = GetAirfoilGrid(airfoilPath=\"examples/single_block_ns/airfoil/data/A-airfoil.txt\", radius = 2)\n# throw away trailing edge stuff\nairfoilGrid = initialGrid[:, 101:end-100, :]\nairfoil = airfoilGrid[:,:,1]\n\n# define the boundary information\nbndInfo = getBoundaryConditions(airfoilGrid)\n\n# define interInfo\ninterInfo = Any[]\n\n#################\n# Make a custom metric\n#################\n\nmetricFunc1 = make_getMetric(airfoil;\n    A_airfoil = 50.0,  ℓ_airfoil = 0.5, p_airfoil = 2,   \n    A_origin  = 500.0,  ℓ_origin  = 0.1, p_origin  = 10,   \n    floor     = 1e-4,  origin_center=(1, -0.6),\nprofile   = :rational)  # or :gauss\n\nmetricFunc2 = make_getMetric(airfoil;\n    A_airfoil = 0.0,  ℓ_airfoil = 0.5, p_airfoil = 2,   \n    A_origin  = 700.0,  ℓ_origin  = 0.1, p_origin  = 10,   \n    floor     = 1e-4,  origin_center=(0.5, 0.1),\nprofile   = :rational)  # or :gauss\n\nmetricFunc = (x,y) -> metricFunc1(x,y) .+ metricFunc2(x,y)\n\n\n\n#################\n# Add split locations \n#################\n\n\nsplitLocations = [\n    [ 300, 500 ],   # split along the x axis\n    [ 40, 80 ]      # split along the y axis\n]\n\n#################\n## Split the blocks\n#################\n\nblocks, bndInfo, interInfo = GridGeneration.SplitBlock(airfoilGrid, splitLocations, bndInfo, interInfo)\n\n#################\n##### Run the solver on them\n#################\n\nblocks, bndInfo, interInfo = GridGeneration.SolveAllBlocks(metricFunc, blocks, bndInfo, interInfo)","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"which yields","category":"page"},{"location":"pages/SingleBlock/splitting/","page":"Single Block with Splitting","title":"Single Block with Splitting","text":"(Image: example1)","category":"page"},{"location":"#GridGeneration.EllipticParams","page":"Home","title":"GridGeneration.EllipticParams","text":"GridGeneration.EllipticParams\n\nmax_iter::Int # maximum number of iterations\ntol::Float64 # tolerance for convergence\nω::Float64 # relaxation factor\nuseTopWall::Bool # whether to apply forcing on the top wall\nuseBottomWall::Bool # whether to apply forcing on the bottom wall\nuseLeftWall::Bool # whether to apply forcing on the left wall\nuseRightWall::Bool # whether to apply forcing on the right wall\nadecayleft::Float64 # decay parameter for left wall forcing\nbdecayleft::Float64 # decay parameter for left wall forcing\nadecayright::Float64 # decay parameter for right wall forcing\nbdecayright::Float64 # decay parameter for right wall forcing\nadecaytop::Float64 # decay parameter for top wall forcing\nbdecaytop::Float64 # decay parameter for top wall forcing\nadecaybottom::Float64 # decay parameter for bottom wall forcing\nbdecaybottom::Float64 # decay parameter for bottom wall forcing\nverbose::Bool # whether to print convergence information\n\n\n\n\n\n","category":"type"},{"location":"#GridGeneration.SimParams","page":"Home","title":"GridGeneration.SimParams","text":"GridGeneration.SimParams\n\nuseSplitting::Bool # whether to use block splitting\nsplitLocations::Vector{Vector{Int}} # locations to split the grid, defined using indices of the initial grid\nuseEdgeSolver::Bool # whether to use the edge solver on each block after splitting\nboundarySolver::Symbol # :analytic or :numeric, which boundary solver to use\nuseSmoothing::Bool # whether to use smoothing on the final grid\nsmoothMethod::Symbol # :ellipticSS, which smoothing method to use\nelliptic::EllipticParams # parameters for the elliptic solver if using elliptic smoothing\n\n\n\n\n\n","category":"type"},{"location":"#GridGeneration.TFI","page":"Home","title":"GridGeneration.TFI","text":"2D Transfinite interpolation (Coons patch). Input boundary with order: (top, right, bottom, left), each as an N×2 array. Returns X', Y' (matching your original orientation).\n\n\n\n\n\n","category":"function"},{"location":"#GridGeneration.make_getMetric","page":"Home","title":"GridGeneration.make_getMetric","text":"make_getMetric(boundary; closed=true,\n               A_airfoil=1.0, ℓ_airfoil=0.05, p_airfoil=2,\n               A_origin=1.0,  ℓ_origin=0.10, p_origin=2,\n               floor=1e-4, profile=:rational)\n\nCreate a closure getMetric(x,y) => (M11, M22) where the scalar field w(x,y) = floor + wairfoil(disttoairfoil) + worigin(disttoorigin) is applied isotropically: M11 = M22 = w.\n\nboundary is a 2×N polyline for the airfoil (assumed closed by default).\nA_* set the peak amplitudes.\nℓ_* set decay lengths (units = your coordinate units).\np_* control tail sharpness for the rational profile.\nfloor prevents degeneracy far away.\nprofile=:rational or :gauss.\n\n\n\n\n\n","category":"function"},{"location":"#GridGeneration.SplitMultiBlock","page":"Home","title":"GridGeneration.SplitMultiBlock","text":"Split multiple blocks with automatic propagation of split constraints across interfaces.\n\nInputs:\n\nblocks: Vector of 3D grid arrays\nsplitRequests: Vector of tuples (blockId, [[isplits], [jsplits]])               or Dict mapping blockId => [[isplits], [jsplits]]\nbndInfo: Boundary condition dictionary\ninterInfo: Interface connectivity dictionary\n\nReturns:\n\nnewBlocks: Vector of split blocks (globally renumbered)\nnewBndInfo: Updated boundary information\nnewInterInfo: Updated interface information\n\n\n\n\n\n","category":"function"},{"location":"#GridGeneration.jl-Documentation","page":"Home","title":"GridGeneration.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation and formulation for GridGeneration.jl","category":"page"},{"location":"#Current-Example","page":"Home","title":"Current Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Just finished adding examples for airfoil case","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A brief description of the underlying ordinary differential equation (ODE) is presented in ODE Formulation with supporting work shown in Mathematical Work. The ODE is nonlinear and second order boundary value problem which can be reformulated as a system system of first order ODEs. Two numerical methods, one for the First Order System using Julia's library DifferentialEquations.jl and second for the Second Order BVP ODE using central differencing and fixed point iteration with under-relaxation. Both methods prove to be rather unstable so a semi-analytical method (semi due to the use of numerical integration and inversion) is adopted. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"To create 2D and 3D grids, we present a method of Mapping 2D to 1D and 1D back to 2D. ","category":"page"},{"location":"#","page":"Home","title":"","text":"","category":"section"},{"location":"#-2","page":"Home","title":"","text":"","category":"section"},{"location":"#-3","page":"Home","title":"","text":"","category":"section"},{"location":"#-4","page":"Home","title":"","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Work is down under the supervision and support of Dr. Larsson at the University of Maryland.","category":"page"}]
}
